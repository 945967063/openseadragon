<!DOCTYPE html>
<html>
<head>
    <title>SdpcRtc WebRTC TileSource Integration Example</title>
    <script type="text/javascript" src="build/openseadragon/openseadragon.js"></script>
    <script type="text/javascript" src="webrtc-tilesource.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        
        .container {
            display: flex;
            gap: 20px;
        }
        
        .viewer-container {
            width: 800px;
            height: 600px;
            border: 1px solid #ccc;
        }
        
        .controls {
            width: 300px;
        }
        
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            background-color: #f0f0f0;
        }
        
        .status.connected {
            background-color: #d4edda;
            color: #155724;
        }
        
        .status.error {
            background-color: #f8d7da;
            color: #721c24;
        }
        
        .log {
            height: 200px;
            overflow-y: auto;
            border: 1px solid #ccc;
            padding: 10px;
            font-family: monospace;
            font-size: 12px;
            background-color: #f8f9fa;
        }
        
        button {
            padding: 8px 16px;
            margin: 5px;
            border: none;
            border-radius: 4px;
            background-color: #007bff;
            color: white;
            cursor: pointer;
        }
        
        button:hover {
            background-color: #0056b3;
        }
        
        button:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
        }
        
        .config {
            margin: 10px 0;
            padding: 10px;
            background-color: #e9ecef;
            border-radius: 4px;
        }
        
        .config input {
            width: 100%;
            margin: 5px 0;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <h1>SdpcRtc WebRTC TileSource é›†æˆç¤ºä¾‹</h1>
    <p>æ¼”ç¤ºå¦‚ä½•ä½¿ç”¨ SdpcRtc ä¸ WebRTC TileSource ç»„ä»¶é›†æˆ</p>
    
    <div class="container">
        <div>
            <div id="viewer" class="viewer-container"></div>
        </div>
        
        <div class="controls">
            <h3>SdpcRtc é…ç½®</h3>
            
            <div class="config">
                <label>WebSocket URL:</label>
                <input type="text" id="wsUrl" value="ws://192.168.10.204:8810" />
                
                <label>å®ä¾‹ID:</label>
                <input type="text" id="instanceId" value="202204071103" />
                
                <label>é€šé“åç§°:</label>
                <input type="text" id="channelName" value="default_channel" />
            </div>
            
            <div id="status" class="status">
                çŠ¶æ€: æœªè¿æ¥
            </div>
            
            <button id="connectBtn" onclick="connectSdpcRtc()">è¿æ¥ SdpcRtc</button>
            <button id="disconnectBtn" onclick="disconnect()" disabled>æ–­å¼€è¿æ¥</button>
            
            <h4>æ—¥å¿—</h4>
            <div id="log" class="log"></div>
            <button onclick="clearLog()">æ¸…ç©ºæ—¥å¿—</button>
        </div>
    </div>

    <script>
        // å…¨å±€å˜é‡
        let viewer = null;
        let webrtcTileSource = null;
        let sdpcRtc = null;
        let isConnected = false;

        // æ¨¡æ‹Ÿ SdpcRtc ç±»ï¼ˆå®é™…ä½¿ç”¨æ—¶è¯·æ›¿æ¢ä¸ºçœŸå®çš„ SdpcRtcï¼‰
        class MockSdpcRtc {
            constructor(config) {
                this.config = config;
                this.channelName = null;
                this.receiveCallback = null;
                this.isConnected = false;
            }

            // æ¨¡æ‹Ÿè¿æ¥
            connect() {
                return new Promise((resolve) => {
                    setTimeout(() => {
                        this.isConnected = true;
                        log('SdpcRtc è¿æ¥æˆåŠŸ');
                        resolve();
                    }, 1000);
                });
            }

            // æ¨¡æ‹Ÿå‘é€åˆ‡ç‰‡è¯·æ±‚
            refreshSlice(channelName, data) {
                if (!this.isConnected) {
                    throw new Error('SdpcRtc not connected');
                }

                log(`å‘é€ refreshSlice: ${data.Method} L${data.Params.Level} X${data.Params.X} Y${data.Params.Y}`);

                // æ¨¡æ‹Ÿå¼‚æ­¥å“åº”
                setTimeout(() => {
                    const mockBase64 = this.generateMockTileBase64(
                        data.Params.Level,
                        data.Params.X,
                        data.Params.Y
                    );

                    const responseData = {
                        data: {
                            sliceId: `${data.Params.Level}_${data.Params.X}_${data.Params.Y}`,
                            requestId: `GetTile ${data.Params.Level} ${data.Params.X} ${data.Params.Y}`,
                            responseCode: 200,
                            resposeData: mockBase64
                        }
                    };

                    if (this.receiveCallback) {
                        this.receiveCallback({
                            data: JSON.stringify(responseData)
                        });
                    }
                }, 100 + Math.random() * 300);
            }

            // æ¨¡æ‹Ÿè¯»å–åˆ‡ç‰‡
            readSlice(fileInfo, data) {
                log(`è¯»å–åˆ‡ç‰‡: ${data.data.sliceId}`);
                
                // æ¨¡æ‹Ÿå¤„ç†å®Œæˆåçš„å“åº”
                setTimeout(() => {
                    if (this.receiveCallback) {
                        this.receiveCallback({
                            data: JSON.stringify({
                                data: {
                                    requestId: data.data.requestId,
                                    responseCode: data.data.responseCode,
                                    resposeData: data.data.resposeData
                                }
                            })
                        });
                    }
                }, 50);
            }

            // ç”Ÿæˆæ¨¡æ‹Ÿç“¦ç‰‡
            generateMockTileBase64(level, x, y) {
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 256;
                const ctx = canvas.getContext('2d');
                
                const hue = ((x * 137 + y * 197 + level * 73) % 360);
                const saturation = 70 + (level * 10) % 30;
                const lightness = 50 + (x + y) % 30;
                
                ctx.fillStyle = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                ctx.fillRect(0, 0, 256, 256);
                
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 1;
                for (let i = 0; i <= 256; i += 32) {
                    ctx.beginPath();
                    ctx.moveTo(i, 0);
                    ctx.lineTo(i, 256);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(0, i);
                    ctx.lineTo(256, i);
                    ctx.stroke();
                }
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`L${level}`, 128, 128);
                ctx.fillText(`X${x} Y${y}`, 128, 148);
                
                return canvas.toDataURL('image/png').split(',')[1];
            }

            disconnect() {
                this.isConnected = false;
                log('SdpcRtc è¿æ¥å·²æ–­å¼€');
            }
        }

        // æ¨¡æ‹Ÿæ–‡ä»¶ä¿¡æ¯
        const files = {};

        // æ—¥å¿—å‡½æ•°
        function log(message) {
            const logElement = document.getElementById('log');
            const timestamp = new Date().toLocaleTimeString();
            logElement.innerHTML += `[${timestamp}] ${message}<br>`;
            logElement.scrollTop = logElement.scrollHeight;
            console.log(message);
        }

        function clearLog() {
            document.getElementById('log').innerHTML = '';
        }

        // æ›´æ–°çŠ¶æ€
        function updateStatus(message, type = 'normal') {
            const statusElement = document.getElementById('status');
            statusElement.textContent = `çŠ¶æ€: ${message}`;
            statusElement.className = `status ${type}`;
        }

        // è¿æ¥ SdpcRtc
        async function connectSdpcRtc() {
            const wsUrl = document.getElementById('wsUrl').value;
            const instanceId = document.getElementById('instanceId').value;
            const channelName = document.getElementById('channelName').value;

            log('å¼€å§‹è¿æ¥ SdpcRtc...');
            updateStatus('è¿æ¥ä¸­...', 'normal');
            
            document.getElementById('connectBtn').disabled = true;

            try {
                // åˆ›å»º SdpcRtc å®ä¾‹ï¼ˆè¿™é‡Œä½¿ç”¨æ¨¡æ‹Ÿç±»ï¼Œå®é™…ä½¿ç”¨æ—¶è¯·æ›¿æ¢ï¼‰
                sdpcRtc = new MockSdpcRtc({
                    wsUrl: wsUrl,
                    instanceId: instanceId,
                    role: 'Sqray' // å¯¹åº” SdpcRtcRole.Sqray
                });

                // è®¾ç½®æ¥æ”¶å›è°ƒ
                sdpcRtc.receiveCallback = (pack) => {
                    const data = JSON.parse(pack.data);
                    log(`æ”¶åˆ°å“åº”: ${JSON.stringify(data.data)}`);
                    
                    // å¦‚æœæœ‰ sliceIdï¼Œè¯´æ˜éœ€è¦è¯»å–åˆ‡ç‰‡
                    if (data.data.sliceId) {
                        // æ¨¡æ‹Ÿæ–‡ä»¶ä¿¡æ¯
                        files[data.data.sliceId] = { name: `tile_${data.data.sliceId}.jpg` };
                        sdpcRtc.readSlice(files[data.data.sliceId], data);
                    } else if (webrtcTileSource) {
                        // ç›´æ¥å¤„ç†å“åº”
                        webrtcTileSource.handleResponse(data.data);
                    }
                };

                // è¿æ¥
                await sdpcRtc.connect();
                
                isConnected = true;
                updateStatus('å·²è¿æ¥', 'connected');
                
                document.getElementById('disconnectBtn').disabled = false;
                
                // åˆå§‹åŒ– OpenSeadragon viewer
                initializeViewer(channelName);
                
            } catch (error) {
                log(`è¿æ¥å¤±è´¥: ${error.message}`);
                updateStatus('è¿æ¥å¤±è´¥', 'error');
                document.getElementById('connectBtn').disabled = false;
            }
        }

        // æ–­å¼€è¿æ¥
        function disconnect() {
            isConnected = false;
            
            if (sdpcRtc) {
                sdpcRtc.disconnect();
                sdpcRtc = null;
            }
            
            updateStatus('å·²æ–­å¼€', 'error');
            
            document.getElementById('connectBtn').disabled = false;
            document.getElementById('disconnectBtn').disabled = true;
            
            if (webrtcTileSource) {
                webrtcTileSource.clearPendingRequests();
            }
            
            if (viewer) {
                viewer.destroy();
                viewer = null;
            }
            
            document.getElementById('viewer').innerHTML = '';
        }

        // åˆå§‹åŒ– OpenSeadragon viewer
        function initializeViewer(channelName) {
            log('åˆå§‹åŒ– OpenSeadragon viewer...');
            
            const tileSourceConfig = {
                type: 'webrtc',
                width: 2048,
                height: 2048,
                tileSize: 256,
                tileOverlap: 0,
                minLevel: 0,
                maxLevel: 6,
                sdpcId: document.getElementById('instanceId').value,
                requestTimeout: 10000,
                sdpcRtc: sdpcRtc,
                channelName: channelName,
                onRequest: function(requestData) {
                    log(`ğŸ“¤ å‘é€è¯·æ±‚: ${requestData.Method} L${requestData.Params.Level} X${requestData.Params.X} Y${requestData.Params.Y}`);
                },
                onResponse: function(responseData, request) {
                    const duration = Date.now() - request.timestamp;
                    log(`ğŸ“¥ æ”¶åˆ°å“åº”: ${responseData.requestId}, è€—æ—¶: ${duration}ms`);
                },
                onError: function(error) {
                    log(`âŒ é”™è¯¯: ${error}`);
                }
            };

            viewer = OpenSeadragon({
                id: 'viewer',
                prefixUrl: 'build/openseadragon/images/',
                showNavigator: true,
                navigatorPosition: 'TOP_RIGHT'
            });

            viewer.addTiledImage({
                tileSource: tileSourceConfig,
                success: function(event) {
                    webrtcTileSource = event.item.source;
                    log('WebRTC TileSource åŠ è½½æˆåŠŸ');
                },
                error: function(event) {
                    log('WebRTC TileSource åŠ è½½å¤±è´¥: ' + event.message);
                }
            });
        }

        // é¡µé¢åŠ è½½å®Œæˆ
        document.addEventListener('DOMContentLoaded', function() {
            log('é¡µé¢åŠ è½½å®Œæˆï¼Œå‡†å¤‡è¿æ¥ SdpcRtc');
            updateStatus('æœªè¿æ¥', 'normal');
        });
    </script>
</body>
</html>
